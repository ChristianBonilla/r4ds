# Transformación de Datos {#transforma}

## Introducción

La visualización es una herramienta importante para el análisis exploratorio, sin embargo es raro que obtengas los datos exactamente en la forma correcta que necesitas. A menudo necesitarás crear variables o estadísticos nuevos, o tal vez solo quieras cambiar el nombre de las variables o reordenar las observaciones para facilitar el trabajo con los datos. En este capítulo aprenderás cómo hacer todo eso (¡y más!), incluyendo cómo transformar tus datos utilizando el paquete dplyr. Utilizaremos un nuevo conjunto de datos sobre salida de vuelos de la ciudad de Nueva York en el año 2013.

### Prerequisitos

En este capítulo nos enfocaremos en cómo usar el paquete dplyr, otro miembro central del tidyverse. Ilustraremos las ideas clave con los datos del paquete vuelos y usaremos ggplot2 para ayudarnos a comprender los datos. 

```{r setup, message = FALSE}
devtools::install_github("cienciadedatos/datos")
data(package = "datos")
library(nycvuelos13)
library(tidyverse)
```

Toma nota acerca del mensaje de conflictos que se imprime cuando carga el paquete tidyverse. Te dice que dplyr sobrescribe algunas funciones en la base de R. Si deseas usar la versión base de estas funciones después de cargar dplyr, necesitarás usar sus nombres completos: `stats::filter()` y `stats::lag()`.

### vuelos

Para explorar los verbos básicos de manipulación de datos de dplyr, usaremos `datos::vuelos`. Este conjunto de datos contiene todos los vuelos `formato r (nrow (datos::vuelos), big.mark =", ")` que partieron de la ciudad de Nueva York durante el 2013. Los datos provienen de las estadísticas de la [Oficina de Transportes de los Estados Unidos](https://www.transtats.bts.gov/DatabaseInfo.asp?DB_ID=120&Link=0), y están documentados en `? datos`.

```{r}
vuelos
```

Es posible que observes que este conjunto de datos se imprime de una forma un poco diferente a otros que podrías haber utilizado en el pasado: solo muestra las primeras filas y todas las columnas que caben en tu pantalla. Para ver todo el conjunto de datos, puedes ejecutar `View(vuelos)` que abrirá el conjunto de datos en el visor de RStudio. En este caso se imprime de manera diferente porque es un __tibble__. Los Tibbles son marcos de datos, pero ligeramente ajustados para que funcionen mejor en el tidyverse. Por ahora, no necesitas preocuparte por las diferencias; volveremos a tibbles con más detalle en [doma] (# doma-intro).

También podrás haber notado la fila de tres (o cuatro) abreviaturas de letras debajo de los nombres de las columnas. Estos describen el tipo de cada variable:

* `int` significa enteros.

* `dbl` representa dobles, o números reales.

* `chr` significa vectores de caracteres o cadenas.

* `dttm` significa fechas y horas (una fecha + una hora).

Hay otros tres tipos comunes de variables que no se usan en este conjunto de datos, pero que encontrará más adelante en el libro:

* `lgl` significa vectores lógicos que solo contienen ` TRUE` (verdadero) o `FALSE` (falso).

* `fctr` significa factores, que R usa para representar variables categóricas con valores posibles fijos.

* `date` significa fechas.

### Lo básico de dplyr 

En este capítulo, aprenderás las cinco funciones clave de dplyr que te permiten resolver la gran mayoría de tus desafíos de manipulación de datos:

* Filtra o elije las observaciones por sus valores (`filter()` — del inglés filtrar).
* Reordena las filas (`arrange()` — del inglés arreglar).
* Selecciona las variables por sus nombres (`select()` — del inglés seleccionar).
* Crea nuevas variables con transformaciones de variables existentes (`mutate()` — del inglés mutar o transformar).
* Contraer muchos valores hasta un solo resumen (`summarize()` — del inglés resumir).

Todo esto se puede usar junto con `group_by()` (— agrupar por en inglés), que cambia el alcance de cada función para que funcione ya no en todo el conjunto de datos sino que funcione grupo por grupo. Estas seis funciones proporcionan los verbos para un lenguaje de manipulación de datos.

Todos los verbos funcionan de manera similar:

1. El primer argumento es un marco de datos.

2. Los argumentos posteriores describen qué hacer con el marco de datos usando los nombres de variables (sin comillas).

3. El resultado es un nuevo marco de datos.

En conjunto, estas propiedades hacen que sea fácil encadenar varios pasos simples para lograr un resultado complejo. Vamos a sumergirnos y ver cómo funcionan estos verbos.

## Filtrar filas con `filter()`

`filter()` te permite filtrar un subconjunto de observaciones basadas en sus valores. El primer argumento es el nombre del marco de datos. El segundo y siguientes argumentos son las expresiones que filtran el marco de datos. Por ejemplo, podemos seleccionar todos los vuelos del 1 de enero con:

```{r}
filter(vuelos, mes == 1, dia == 1)
```

Cuando ejecutas esa línea de código, dplyr ejecuta la operación de filtrado y devuelve un nuevo marco de datos. Las funciones dplyr nunca modifican sus entradas, por lo que si deseas guardar el resultado, necesitarás usar el operador de asignación, `<-`:

```{r}
ene1 <- filter(vuelos, mes == 1, dia == 1)
```

R imprime los resultados o los guarda en una variable. Si deseas hacer ambas cosas, puedes escribir toda la línea entre paréntesis:

```{r}
(dic25 <- filter(vuelos, mes == 12, dia == 25))
```

### Comparaciones

Para usar el filtrado de manera efectiva, debes saber cómo seleccionar las observaciones que deseas utilizando los operadores de comparación. R proporciona la suite estándar: `>`, `> =`, `<`, `<=`, `! =` (No igual) y `==` (igual).

Cuando comienzas con R, el error más fácil de cometer es usar `=` en lugar de `==` cuando se prueba la igualdad. Cuando esto sucede, obtendrás un error informativo:

```{r, error = TRUE}
filter(vuelos, mes = 1)
```

Hay otro problema común que puedes encontrar al usar `==`: números de coma flotante. ¡Estos resultados pueden sorprenderte!

```{r}
sqrt(2) ^ 2 == 2
1 / 49 * 49 == 1
```

Las computadoras usan aritmética de precisión finita (obviamente no pueden almacenar una cantidad infinita de dígitos) Así que recuerda que cada número que ves es una aproximación. En lugar de confiar en `==`, usa `near()` (cercano en inglés):

```{r}
near(sqrt(2) ^ 2,  2)
near(1 / 49 * 49, 1)
```

### Operadores lógicos

Múltiples argumentos para `filter()` se combinan con "y": cada expresión debe ser verdadera para que una fila se incluya en la salida. Para otros tipos de combinaciones, necesitarás usar operadores Booleanos: `&` es "y", `|` es "o", y `!` Es "no". La figura @ref(fig:bool-ops) muestra el conjunto completo de operaciones Booleanas.

```{r bool-ops, echo = FALSE, fig.cap = "Set Completo de Operaciones Booleanas. `x` es el círculo de la izquierda, `y` es el círculo de la derecha, y la región sombreada muestra qué partes selecciona cada operador."}
knitr::include_graphics("diagrams/transform-logical.png")
```

El siguiente código encuentra todos los vuelos que partieron en noviembre o diciembre:

```{r, eval = FALSE}
filter(vuelos, mes == 11 | mes == 12)
```

El orden de las operaciones no funciona como en español. No puedes escribir `filter (vuelos, mes == 11 | 12)`, que literalmente puede traducirse como "encuentra todos los vuelos que partieron en noviembre o diciembre". En cambio, encontrará todos los meses que son iguales a `11 | 12`, una expresión que evalúa a 'VERDADERO'. En un contexto numérico (como aquí), 'VERDADERO' se convierte en un uno, por lo que encuentra todos los vuelos en enero, no en noviembre o diciembre. Esto es bastante confuso.

Una manera rápida y útil para resolver este problema es `x %in% y` (x en y en inglés). Esto seleccionará cada fila donde `x` es uno de los valores en` y`. Podríamos usarlo para reescribir el código de arriba:

```{r, eval = FALSE}
nov_dic <- filter(vuelos, mes %in% c(11, 12))
```

A veces puedes simplificar subconjuntos complicados al recordar la ley de De Morgan: `!(x & y)` es lo mismo que `!x | !y`, y `!(x | y)` es lo mismo que `!x & !y`. Por ejemplo, si deseas encontrar vuelos que no se retrasaron (en llegada o partida) en más de dos horas, puedes usar cualquiera de los dos filtros siguientes:

```{r, eval = FALSE}
filter(vuelos, !(lleg_tardia > 120 | sal_tardia > 120))
filter(vuelos  , lleg_tardia <= 120, sal_tardia <= 120)
```

Además de `&` y `|`, R también tiene `&&` y `||`. ¡No los uses aquí! Aprenderás cuándo debe usarlos en [ejecución condicional].

Siempre que empieces a usar expresiones complejas de varias partes en `filter()`, considera convertirlas en variables explícitas. Eso hace que sea mucho más fácil verificar tu trabajo. Aprenderás cómo crear nuevas variables en breve.

### Valores faltantes

Una característica importante de R que puede hacer que la comparación sea difícil son los valores faltantes, o `NA`s ("no disponibles en inglés"). `NA` representa un valor desconocido por lo que los valores perdidos son "contagiosos": casi cualquier operación que involucre un valor desconocido también será desconocida.

```{r}
NA > 5
10 == NA
NA + 10
NA / 2
```

El resultado más confuso es este:

```{r}
NA == NA
```

Es más fácil entender por qué esto es cierto con un poco más de contexto:

```{r}
# Sea x la edad de María. No sabemos qué edad tiene.
x <- NA

# Sea y la edad de Juan. No sabemos qué edad tiene.
y <- NA

# ¿Tienen Juan y María la misma edad?
x == y
# ¡No sabemos!
```

Si deseas determinar si falta un valor, usa `is.na()`:

```{r}
is.na(x)
```

`filter()` solo incluye filas donde la condición es `TRUE`; excluye ambos valores `FALSE` y `NA`. Si deseas conservar valores perdidos, solicítalos explícitamente:

```{r}
df <- tibble(x = c(1, NA, 3))
filter(df, x > 1)
filter(df, is.na(x) | x > 1)
```

### Ejercicios

1.  Encuentra todos los vuelos que:

   i.   Tuvieron un retraso de llegada de dos o más horas
  
   ii.  Volaron a Houston (`IAH` o` HOU`)
   
   iii. Fueron operados por United, American o Delta
   
   iv.  Partieron en verano (julio, agosto y septiembre)
   
   v.   Llegaron más de dos horas tarde, pero no salieron tarde
   
   vi.  Se retrasaron por lo menos una hora, pero repusieron más de 30 minutos en vuelo
   
   vii. Partieron entre la medianoche y las 6 a.m. (inclusive)

2.  Otro filtrado útil de dplyr es `between()`. ¿Qué hace? ¿Puedes usarlo para simplificar el código necesario para responder a los desafíos anteriores?

3. ¿Cuántos vuelos tienen datos faltantes de `dep_time`? ¿Qué otras variables tienen valores faltantes? ¿Qué representan estas filas?

4. ¿Por qué `NA ^ 0` no es faltante? ¿Por qué `NA | TRUE` no es faltante? ¿Por qué `FALSE & NA` no es faltante? ¿Puedes descubrir la regla general? (`NA * 0` es un contraejemplo complicado!)

## Reordena las filas con `arrange()`

`arrange()` funciona de manera similar a `filter()` excepto que en lugar de seleccionar filas, cambia su orden. La función toma un marco de datos y un conjunto de nombres de columna (o expresiones más complicadas) para ordenar acorde. Si proporcionas más de un nombre de columna, cada columna adicional se utilizará para romper empates en los valores de las columnas anteriores:

```{r}
arrange(vuelos, anio, mes, dia)
```

Usa `desc()` para reordenar por una columna en orden descendente:

`` `{r}
arrange(vuelos, desc(sal_tardia))
`` `

Los valores faltantes siempre se ordenan al final:

```{r}
df <- tibble(x = c (5, 2, NA))
arrange(df, x)
arrange(df, desc(x))
```

### Ejercicios

1. ¿Cómo podrías usar `arrange()` para ordenar todos los valores perdidos al comienzo? (Sugerencia: usa `is.na()`).
    
2. Ordena `vuelos` para encontrar los vuelos más retrasados. Encuentra los vuelos que salieron más temprano.

3. Ordena `vuelos` para encontrar los vuelos más rápidos.

4. ¿Cuáles vuelos viajaron más tiempo? ¿Cuál viajó menos tiempo?

## Selecciona columnas con `select()` {#selecciona}

No es raro obtener conjuntos de datos con cientos o incluso miles de variables. En este caso, el primer desafío a menudo se reduce a las variables que realmente te interesan. `select()` te permite seleccionar rápidamente un subconjunto útil utilizando operaciones basadas en los nombres de las variables.

`select()` no es muy útil con los datos de los vuelos porque solo tenemos 19 variables, pero aún podemos describir la idea general:

```{r}
# Seleccionar columnas por nombre
select(vuelos, anio, mes, día)
# Seleccionar todas las columnas entre año y día (inclusive)
select(vuelos, anio: día)
# Seleccionar todas las columnas excepto aquellas entre año en día (inclusive)
select(vuelos, - (anio: día))
```

Hay una serie de funciones auxiliares que puede usar dentro de `select()`:

* `starts_with("abc")`: coincide con nombres que comienzan con "abc".

* `ends_with("xyz")`: coincide con los nombres que terminan con "xyz".

* `contains("ijk")`: coincide con los nombres que contienen "ijk".

* `matches("(.)\\1")`: selecciona variables que coinciden con una expresión regular. Éste coincide con cualquier variable que contenga caracteres repetidos. Aprenderás más sobre expresiones regulares en [strings].

* `num_range("x", 1:3)`: coincide con `x1`,` x2` y `x3`.

Ver `?select` para más detalles.

`select()` se puede usar para cambiar el nombre de las variables, pero rara vez es útil porque descarta todas las variables que no se mencionan explícitamente. En su lugar, utiliza `rename()`, que es una variante de `select()` que mantiene todas las variables que no se mencionan explícitamente:

`` `{r}
rename(vuelos, cola_num = colanum)
`` `

Otra opción es usar `select()` junto con el asistente `everything()` (todo en inglés). Esto es útil si tienes un grupo de variables que te gustaría mover al comienzo del marco de datos.

```{r}
select(vuelos, time_hour, air_time, everything())
```

### Ejercicios

1. Haz una lluvia de ideas de tantas maneras como sea posible para seleccionar `dep_time`,` dep_delay`,`arr_time`, y` arr_delay` de `vuelos`.

2. ¿Qué sucede si incluyes el nombre de una variable varias veces en una llamada `select()`?

3. ¿Qué hace la función `one_of()`? Por qué podría ser útil en conjunto con este vector?

```{r}
vars <- c ("anio", "mes", "día", "dep_delay", "arr_delay")
```

4. ¿Te sorprende el resultado de ejecutar el siguiente código? ¿Cómo tratan el caso por defecto los ayudantes seleccionados? ¿Cómo puedes cambiar ese valor predeterminado?

```{r, eval = FALSE}
select(vuelos, contains("HORA"))
```

## Crea nuevas variables con `mutate()`

Además de seleccionar conjuntos de columnas existentes, a menudo es útil crear nuevas columnas como funciones de columnas existentes. Ese es el trabajo de `mutate()` (mutar en inglés).

`mutate()` siempre agrega nuevas columnas al final de st conjunto de datos, así que comenzaremos creando un conjunto de datos más pequeño para que podamos ver las nuevas variables. Recuerda que cuando usas RStudio, la manera más fácil de ver todas las columnas es `View()`.

```{r}
vuelos_sml <- select(vuelos,
  anio:dia,
  ends_with("retraso"),
  distancia,
  air_time
)
mutate(vuelos_sml,
  gain = dep_delay - arr_delay,
  velocidad = distancia / tiempo_viento * 60
)
```

Ten en cuenta que puedes consultar las columnas que acabas de crear:

```{r}
mutate(vuelos_sml,
  gain = dep_delay - arr_delay,
  horas = air_time / 60,
  gain_per_hour = ganancia / horas
)
```

Si solo quiere conservar las nuevas variables, use `transmute ()`:

```{r}
transmutate(vuelos_sml,
  gain = dep_delay - arr_delay,
  horas = air_time / 60,
  gain_per_hour = ganancia / horas
)
```

### Funciones de creación útiles {# mutate-funs}

Hay muchas funciones para crear nuevas variables que se puede usar con `mutate()`. La propiedad clave es que la función debe ser vectorizada: debe tomar un vector de valores como input, y devolver un vector con el mismo número de valores como output. No hay forma de enumerar todas las posibles funciones que podrías usar, pero aquí hay una selección de funciones que son útiles frecuentemente:

* Operadores aritméticos: `+`, `-`,`*`,`/`,`^`. Todos están vectorizados, usando las llamadas "reglas de reciclaje". Si un parámetro es más corto que el otro, se extenderá automáticamente para tener la misma longitud. Esto es muy útil cuando uno de los argumentos es un solo número: `air_time / 60`, `horas * 60 + minuto`, etc. Los operadores aritméticos también son útiles junto con el funciones de agregar de las que aprenderás más tarde. Por ejemplo, `x / sum (x)` calcula la proporción de un total, y `y - media (y)` calcula la diferencia de la media.

* Aritmética modular: `%/%` (división entera) y `%%` (resto), donde `x == y * (x%/% y) + (x %% y)`. La aritmética modular es una herramienta útil porque te permite dividir enteros en partes. Por ejemplo, en el conjunto de datos de vuelos, puedes calcular `hour` y` minute` de `dep_time` con:

```{r}
transmute(vuelos,
  dep_time,
  hora = dep_time% /% 100,
  minuto = dep_time %% 100
)
```

* Logaritmos: `log()`, `log2()`, `log10()`. Los logaritmos son increíblemente útiles como transformación para hacer frente a los datos con múltiples órdenes de magnitud. También convierten las relaciones multiplicativas en aditivos, una característica muy útil para el modelado. En igualdad de condiciones, recomendamos usar `log2()` porque es más fácil de interpretar: una diferencia de 1 en la escala de registro corresponde a la duplicación de la escala original y una diferencia de -1 corresponde a la mitad.

* Rezagos: `lead()` y `lag()` te permiten referirte a un valor adelante o un valor atrás (con rezago). Esto te permite calcular las diferencias móviles (por ejemplo, `x - lag(x)`) o buscar cuáles y dónde cambian los valores (`x! = lag (x)`). Estos comandos son más útiles cuando se utilizan junto con `group_by()`, que lo aprenderás en breve.

```{r}
(x <- 1:10)
lag(x)
lead(x)
```

* Agregados acumulativos y acumulados: R proporciona funciones para ejecutar sumas, productos, mínimos y máximos: `cumsum()`, `cumprod()`, `cummin()`, `cummax()`; y dplyr proporciona `cummean()` para la media acumulada. Si necesitas calcular agregados móviles (es decir, una suma calculada en una ventana móvil), prueba el paquete RcppRoll.

```{r}
x
cumsum(x)
cummean(x)
```

* Comparaciones lógicas: antes aprendimos: `<`, `<=`, `>`, `> =`, `! =`. Si estás haciendo una secuencia compleja de operaciones lógicas, es a menudo es una buena idea almacenar los valores provisionales en nuevas variables para que puedas comprobar que cada paso funciona como se espera.

* Clasificación: hay una serie de funciones de clasificación, pero deberías comenzar con `min_rank()`. Esta función realiza el tipo más común de clasificación (por ejemplo, primero, segundo, tercero, etc). El valor predeterminado otorga la menor posición a los valores más pequeños; usa `desc(x)` para dar la menor posición a los valores más grandes.

```{r}
y <- c (1, 2, 2, NA, 3, 4)
min_rank(y)
min_rank(desc(y))
```

Si `min_rank()` no hace lo que necesitas, consulta las variantes `row_number()`, `dense_rank()`, `percent_rank()`, `cume_dist()`,
`ntile()`. Ve sus páginas de ayuda para más detalles.

```{r}
row_number(y)
dense_rank(y)
percent_rank(y)
cume_dist(y)
```

### Ejercicios

```{r, eval = FALSE, echo = FALSE}
vuelos <- vuelos %>% mutate(
  dep_time = hour * 60 + minute,
  arr_time = (arr_time %/% 100) * 60 + (arr_time %% 100),
  airtime2 = arr_time - dep_time,
  dep_sched = dep_time + dep_delay
)

ggplot(vuelos, aes(dep_sched)) + geom_histogram(binwidth = 60)
ggplot(vuelos, aes(dep_sched %% 60)) + geom_histogram(binwidth = 1)
ggplot(vuelos, aes(air_time - airtime2)) + geom_histogram()
```

1. Las variables `dep_time` y` sched_dep_time` tienen un formato conveniente para leer, pero es difícil realizar cualquier cálculo con ellas porque no son realmente números continuos. Conviértelos en una representación más conveniente de la cantidad de minutos desde la medianoche.

2. Compara `air_time` con` arr_time - dep_time`. ¿Qué esperas ver? ¿Qué ves? ¿Qué necesitas hacer para arreglarlo?

3. Compara `dep_time`,` sched_dep_time`, y `dep_delay`. ¿Cómo esperarías que esos tres números estén relacionados?

4. Encuentra los 10 vuelos más retrasados utilizando una función de clasificación. ¿Cómo quieres para manejar los empates? Lee atentamente la documentación de `min_rank()`.

5. ¿Qué devuelve `1: 3 + 1: 10`? ¿Por qué?

6. ¿Qué funciones trigonométricas proporciona R?

## Resúmenes agrupados con `summarize()`

El último verbo clave es `summarize()` (de resumir en inglés). Se encarga de colapsar un marco de datos en una sola fila:

`` `{r}
summarize(vuelos, demora = mean(dep_delay, na.rm = TRUE))
`` `

(Volveremos a lo que significa `na.rm = TRUE` en muy poco tiempo).

`summarize()` no es muy útil a menos que lo emparejemos con `group_by()`. Esto cambia la unidad de análisis del conjunto de datos completo a grupos individuales. Luego, cuando uses los verbos dplyr en un marco de datos agrupado, aplicarás automáticamente "por grupo". Por ejemplo, si aplicamos exactamente el mismo código a un marco de datos agrupado por fecha, obtenemos el retraso promedio por fecha:

```{r}
by_day <- group_by (vuelos, anio, mes, dia)
summarize(by_day, delay = mean(dep_delay, na.rm = TRUE))
```

Juntos `group_by ()` y `summarize ()` proporcionan una de las herramientas que usarás más comúnmente cuando trabajes con dplyr: resúmenes agrupados. Pero antes de ir más allá con esto, tenemos que introducir una idea nueva y poderosa: la tubería o dataducto.

### Combinación de múltiples operaciones con la tubería

Imagina que queremos explorar la relación entre la distancia y la demora promedio para cada ubicación. Usando lo que sabes acerca de dplyr, podrías escribir un código como este:

```{r, fig.width = 6}
by_dest <- group_by(vuelos, dest)
delay <- summarize(by_dest,
  count = n(),
  dist = mean(distancia, na.rm = TRUE),
  delay = mean(arr_delay, na.rm = TRUE)
)
delay <- filter(delay, count> 20, dest!= "HNL")

# Parece que las demoras aumentan con una distancia de hasta ~ 750 millas
# y luego disminuyen. Tal vez a medida que los vuelos se hacen más 
# largos, hay más habilidad para compensar las demoras en el aire?

ggplot (data = delay, mapping = aes (x = dist, y = retraso)) +
  geom_point (aes (size = count), alpha = 1/3) +
  geom_smooth (se = FALSE)
```

Hay tres pasos para preparar esta información:

1. Agrupa los vuelos por destino.

2. Resume en cada grupo para calcular la distancia, la demora promedio y el número de vuelos.

3. Filtra para eliminar puntos ruidosos y el aeropuerto de Honolulu, que está casi dos veces más lejos que el próximo aeropuerto más cercano.

Es un poco frustrante escribir este código porque tenemos que dar un nombre a cada marco de datos intermedio, aunque no nos importe. Nombrar cosas es difícil, por lo que esto de nuestro análisis más lento y complicado.

Hay otra forma de abordar el mismo problema con la tubería (del inglés pipe que también significa pipa en español), `%>%`:

```{r}
delays <- vuelos %>% 
  group_by(dest) %>% 
  summarise(
    count = n(),
    dist = mean(distance, na.rm = TRUE),
    delay = mean(arr_delay, na.rm = TRUE)
  ) %>% 
  filter(count > 20, dest != "HNL")
```

Esto se enfoca en las transformaciones, no en lo que se está transformando, lo que hace que el código sea más fácil de leer. Puedes leerlo como una serie de declaraciones imperativas: agrupa, luego resume y por último filtra. Como sugiere esta lectura, una buena forma de pronunciar `%>%` cuando se lee el código es "y luego".  

Lo que encuentras detrás del código, es que `x%>% f(y)` se convierte en `f(x, y)`, y `x%>% f(y)%>% g(z)` se convierte en `g(f(x, y), z)` y así sucesivamente. Puedes usar la tubería para reescribir múltiples operaciones de forma que puedas leer de izquierda a derecha, de arriba hacia abajo. Usaremos tuberías con frecuencia a partir de ahora porque mejora considerablemente la legibilidad del código, y volveremos al tema con más detalle en [pipes].

Trabajar con la tubería es uno de los criterios clave para pertenecer al tidyverse. La única excepción es ggplot2: se escribió antes de que se descubriera la tubería. Lamentablemente, la siguiente iteración de ggplot2, ggvis, que sí utiliza el conducto o tubería, aún no está lista para la audiencia general.  

### Valores Faltantes

Es posible que te hayas preguntado sobre el argumento `na.rm` que utilizamos anteriormente. ¿Qué pasa si no lo configuramos?

```{r}
vuelos %>% 
  group_by(anio, mes, dia) %>% 
  summarise(mean = mean(dep_delay))
```

¡Obtenemos muchos valores faltantes! Esto se debe a que las funciones de agregación obedecen la regla habitual de valores faltantes: si hay algún valor faltante en la entrada, la salida será un valor faltante. Afortunadamente, todas las funciones de agregación tienen un argumento `na.rm` que elimina los valores perdidos antes del cálculo:

```{r}
vuelos %>% 
  group_by(anio, mes, dia) %>% 
  summarise(mean = mean(dep_delay, na.rm = TRUE))
```

En este caso, cuando los valores faltantes representan vuelos cancelados, también podríamos abordar el problema eliminando primero los vuelos cancelados. Guardaremos este conjunto de datos para poder reutilizarlo en los siguientes ejemplos.

```{r}
no_cancelado <- vuelos %>% 
  filter(!is.na(dep_delay), !is.na(arr_delay))

no_cancelado %>% 
  group_by(anio, mes, dia) %>% 
  summarise(mean = mean(dep_delay))
```

### Cuentas

Siempre que realices una agregación, es una buena idea incluir un conteo (`n()`) o un recuento de valores no faltantes (`sum(!is.na(x))`). De esta forma, puedes verificar que no estás sacando conclusiones basadas en cantidades muy pequeñas de datos. Por ejemplo, veamos los aviones (identificados por su número de cola) que tienen las demoras promedio más altas:

```{r}
delays <- no_cancelado %>% 
  group_by(tailnum) %>% 
  summarise(
    delay = mean(arr_delay)
  )

ggplot(data = delays, mapping = aes(x = delay)) + 
  geom_freqpoly(binwidth = 10)
```

¡Hay algunos aviones que tienen una demora promedio de 5 horas (300 minutos)!

La historia es en realidad un poco más matizada. Podemos obtener más información si hacemos un diagrama de dispersión del número de vuelos contra la demora promedio:

```{r}
delays <- no_cancelado %>% 
  group_by(tailnum) %>% 
  summarise(
    delay = mean(arr_delay, na.rm = TRUE),
    n = n()
  )

ggplot(data = delays, mapping = aes(x = n, y = delay)) + 
  geom_point(alpha = 1/10)
```

No es de sorprender que hay una mayor variación en el promedio de retraso cuando hay pocos vuelos. La forma de este gráfico es muy importante: cuando usted traza un promedio (o cualquier otra medida de resumen) contra el tamaño del grupo, verá que la variación decrece cuando el tamaño de muestra aumenta.

Cuando se observan este tipo de gráficos, resulta útil eliminar los grupos con menor número de observaciones, ya que puedes ver más del patrón y menos de la variación extrema de los grupos pequeños. Esto es lo que te muestra cómo hacer el código siguiente, así como también te ofrece una manera muy útil para integrar ggplot2 en dplyr. Es un poco incómodo tener que cambiar de `%>%` a `+`, pero una vez que entiendas el código, verás que es bastante conveniente.

```{r}
delays %>% 
  filter(n > 25) %>% 
  ggplot(mapping = aes(x = n, y = delay)) + 
    geom_point(alpha = 1/10)
```

--------------------------------------------------------------------------------

RStudio tip: un atajo en tu teclado que puede ser muy útil es Cmd/Ctrl + Shift + P. Este reenvía el fragmento enviado previamente del editor a la consola. Esto es muy útil cuando por ejemplo estás explorando el valor de `n` en el ejemplo anterior. Envías todo el bloque a la consola una vez con Cmd / Ctrl + Enter, y luego modificas el valor de `n` y presionas Cmd / Ctrl + Shift + P para reenviar el bloque completo.

--------------------------------------------------------------------------------

Hay otra variación común de este tipo de patrón. Veamos cómo el rendimiento promedio de los bateadores en el béisbol está relacionado con el número de veces que están bateando. Aquí utilizas datos del paquete __Lahman__ para calcular el promedio de bateo (número de bateos / número de intentos) de cada jugador de béisbol de Grandes Ligas.

Cuando graficas la habilidad del bateador (medido por el promedio de bateo, `ba`) contra el número de oportunidades para golpear la pelota (medido por al bate,`ab`), verás dos patrones:

1. Como en el ejemplo anterior, la variación en nuestro estadístico de resumen disminuye a medida que obtenemos más observaciones.

2. Existe una correlación positiva entre la habilidad (`ba`) y las oportunidades para golpear la pelota (`ab`). Esto se debe a que los equipos controlan quién puede jugar, y obviamente elegirán a sus mejores jugadores.

```{r}
# Convert to a tibble so it prints nicely
batting <- as_tibble(Lahman::Batting)

batters <- batting %>% 
  group_by(playerID) %>% 
  summarise(
    ba = sum(H, na.rm = TRUE) / sum(AB, na.rm = TRUE),
    ab = sum(AB, na.rm = TRUE)
  )

batters %>% 
  filter(ab > 100) %>% 
  ggplot(mapping = aes(x = ab, y = ba)) +
    geom_point() + 
    geom_smooth(se = FALSE)
```

Esto también tiene implicaciones importantes para la clasificación. Si ingenuamente ordenas `desc(ba)`, las personas con los mejores promedios de bateo tiene claramente mucha suerte, pero no son necesariamente habilidosos:

```{r}
batters %>% 
  arrange(desc(ba))
```

Puedes encontrar una buena explicación de este problema en <http://varianceexplained.org/r/empirical_bayes_baseball/> y <http://www.evanmiller.org/how-not-to-sort-by-average-rating.html>.

### Funciones de resumen útiles {#summarize-funs}

Solo el uso de medias, cuentas y sumas puede llevarte muy lejos, pero R proporciona muchas otras funciones de resumen útiles:

  *  Medidas de centralidad: hemos usado `mean(x)`, pero `median(x)` también resulta muy útil. La media es la suma dividida por el número de observaciones; la mediana es un valor donde el 50% de `x` está por encima de él, y el 50% está por debajo. A veces es útil combinar agregación con un subconjunto lógico. Todavía no hemos hablado sobre este tipo de subconjuntos, pero aprenderás más al respecto en [subconjunto].
    
```{r}
no_cancelado %>% 
  group_by(anio, mes, dia) %>% 
  summarise(
    avg_delay1 = mean(arr_delay),
    avg_delay2 = mean(arr_delay[arr_delay > 0]) # the average positive delay
  )
```

* Medidas de dispersión: `sd(x)`, `IQR(x)`, `mad(x)`. La raíz de la desviación media al cuadrado o desviación estándar o SD para abreviar, es una medida estándar de dispersión. El rango intercuartil `IQR()` y la desviación media absoluta `mad(x)` son medidas robustas equivalentes que pueden ser más útiles si tienes valores atípicos.

```{r}
# ¿Por qué la distancia a algunos destinos es más variable que la de otros?
no_cancelado %>% 
  group_by(dest) %>% 
  summarise(distance_sd = sd(distance)) %>% 
  arrange(desc(distance_sd))
```
  
* Medidas de rango: `min(x)`, `quantile(x, 0.25)`, `max(x)`. Los cuantiles son una generalización de la mediana. Por ejemplo, `quantile(x, 0.25)` encontrará un valor de `x` que es mayor que el 25% de los valores, y menos que el 75% restante.

```{r}
# ¿Cuándo salen los primeros y los últimos vuelos cada día?
no_cancelado %>% 
  group_by(anio, mes, dia) %>% 
  summarise(
    first = min(dep_time),
    last = max(dep_time)
  )
```
  
* Medidas de posición: `first(x)`, `nth(x, 2)`, `last(x)`. Estas trabajan de forma similar a `x[1]`, `x[2]` y `x[length (x)]`, pero te permiten establecer un valor predeterminado en el caso de que esa posición no exista (es decir, si estás tratando de obtener el tercer elemento de un grupo que solo tiene dos elementos). Por ejemplo, podemos encontrar la primera y última salida para cada día:
    
```{r}
no_cancelado %>% 
  group_by(anio, mes, dia) %>% 
  summarise(
    first_dep = first(dep_time), 
    last_dep = last(dep_time)
  )
```
    
Estas funciones son complementarias al filtrado en rangos. El filtrado da todas las variables, con cada observación en una fila separada:
    
```{r}
no_cancelado %>% 
  group_by(anio, mes, dia) %>% 
  mutate(r = min_rank(desc(dep_time))) %>% 
  filter(r %in% range(r))
```

* Cuentas: has visto `n()`, que no toma argumentos, y devuelve el tamaño del grupo actual. Para contar la cantidad de valores no perdidos, usa `sum(!is.na (x))`. Para contar la cantidad de valores distintos (únicos), usa `n_distinct(x)`.
    
```{r}
# ¿Qué destinos tienen la mayoría de los transportistas?
no_cancelado %>% 
  group_by(dest) %>% 
  summarise(carriers = n_distinct(carrier)) %>% 
  arrange(desc(carriers))
```
    
Las cuentas son tan útiles que dplyr proporciona un ayudante simple si todo lo que quieres es
un conteo:

```{r}
no_cancelado %>% 
  count(dest)
```
    
Opcionalmente puedes proporcionar una variable de peso. Por ejemplo, podrías usar esto para "contar" (o sumar) el número total de millas que un avión voló:

```{r}
no_cancelado %>% 
  count(tailnum, wt = distance)
```
  
* Cuentas y proporciones de valores lógicos: `suma(x> 10)`, `media(y == 0)`. Cuando se usan con funciones numéricas, `TRUE` se convierte en un 1 y `FALSE` en un 0. Esto hace que `sum()` y `mean()` sean muy útiles: `sum(x)` te da la cantidad de `TRUE`s en` x`, y `mean(x)` te da la proporción.

```{r}
# ¿Cuántos vuelos salieron antes de las 5 a.m.? (estos generalmente son vuelos demorados 
# del día anterior)
no_cancelado %>% 
  group_by(anio, mes, dia) %>% 
  summarise(n_early = sum(dep_time < 500))

# ¿Qué proporción de vuelos se retrasan más de una hora?
no_cancelado %>% 
  group_by(anio, mes, dia) %>% 
  summarise(hour_perc = mean(arr_delay > 60))
```

### Agrupación por múltiples variables

Cuando agrupas por múltiples variables, cada resumen se desprende de un nivel de la agrupación. Eso hace que sea más fácil acumular progresivamente en un conjunto de datos:

```{r}
daily <- group_by(vuelos, anio, mes, dia)
(per_day   <- summarise(daily, vuelos = n()))
(per_month <- summarise(per_day, vuelos = sum(vuelos)))
(per_year  <- summarise(per_month, vuelos = sum(vuelos)))
```

Ten cuidado al acumular resúmenes progresivamente: está bien para las sumas y los recuentos, pero debes pensar en la ponderación de las medias y las varianzas, además de que no es posible hacerlo exactamente para estadísticas basadas en rangos como la mediana. En otras palabras, la suma de las sumas agrupadas es la suma total, pero la mediana de las medias agrupadas no es la mediana general.

### Desagrupar

Si necesitas eliminar la agrupación y regresar a las operaciones en datos desagrupados, usa `ungroup()`.

```{r}
daily %>% 
  ungroup() %>%             # ya no está agrupado por fecha
  summarise(vuelos = n())   # todos los vuelos
```

### Ejercicios

1.   Haz una lluvia de ideas de al menos 5 formas diferentes de evaluar las características de un retraso típico de un grupo de vuelos. Considera los siguientes escenarios:
 
 * Un vuelo llega 15 minutos antes 50% del tiempo, y 15 minutos tarde 50% de el tiempo.

 * Un vuelo llega siempre 10 minutos tarde.

 * Un vuelo llega 30 minutos antes 50% del tiempo, y 30 minutos tarde 50% del tiempo.

 * Un vuelo llega a tiempo en el 99% de los casos. 1% de las veces llega 2 horas tarde.

¿Qué es más importante: retraso de la llegada o demora de salida?

2.  Vamos con otro enfoque que te dará el mismo resultado que `no_cancelado %>% count(dest)` y
`no_cancelado %>% count(tailnum, wt = distance)` (sin usar `count()`).

3.  Nuestra definición de vuelos cancelados (`is.na(dep_delay) | is.na (arr_delay)`) es un poco subóptima. ¿Por qué? ¿Cuál es la columna más importante?

4. Mira la cantidad de vuelos cancelados por día. ¿Hay un patrón? ¿La proporción de vuelos cancelados está relacionada con el retraso promedio?

5. ¿Qué compañía tiene los peores retrasos? Desafío: ¿puedes desenredar el efecto de malos aeropuertos vs. el efecto de malos transportistas? ¿Por qué o por qué no? (Sugerencia: piensa en `vuelos %>% group_by(carrier, dest) %>% summarize(n())`)

6. ¿Qué hace el argumento `sort` para `count()`. ¿Cuándo podrías usarlo?

## Transformaciones agrupadas (y filtros)

La agrupación es más útil si se utiliza junto con `summarize()`, pero también puedes hacer operaciones convenientes con `mutate()` y `filter()`:

*   Encuentra los peores miembros de cada grupo:

```{r}
vuelos_sml %>% 
  group_by(year, month, day) %>%
  filter(rank(desc(arr_delay)) < 10)
```

*   Encuentra todos los grupos más grandes que un umbral:

```{r}
popular_dests <- vuelos %>% 
  group_by(dest) %>% 
  filter(n() > 365)
popular_dests
```

*   Estandariza para calcular las métricas por grupo:

```{r}
popular_dests %>% 
  filter(arr_delay > 0) %>% 
  mutate(prop_delay = arr_delay / sum(arr_delay)) %>% 
  select(year:day, dest, arr_delay, prop_delay)
```

Un filtro agrupado es una transformación agrupada seguida de un filtro desagrupado. En general, los evito, excepto por las manipulaciones rápidas y sucias: de lo contrario, es difícil comprobar que has hecho la manipulación correctamente.

Las funciones que trabajan de forma más natural en transformaciones y filtros agrupados se conocen como funciones de ventana (frente a las funciones de resumen utilizadas para los resúmenes). Puedes obtener más información sobre las funciones de ventana útiles en la viñeta correspondiente: `vignette("window-functions")`.

### Ejercicios

1. Remítete a las listas de funciones útiles de mutación y filtrado. Describe cómo cambia cada operación cuando las combinas con la agrupación.

2. ¿Qué avión (`colanum`) tiene el peor registro de tiempo?

3. ¿A qué hora del día deberías volar si quieres evitar retraso lo más posible?

4. Para cada destino, calcula los minutos totales de demora. Para cada vuelo, calcula la proporción de la demora total para su destino.

5. Los retrasos suelen estar temporalmente correlacionados: incluso una vez que el problema que causó el retraso inicial se ha resuelto, los vuelos posteriores se retrasan para permitir que salgan los vuelos anteriores. Usando `lag()`, explora cómo el retraso de un vuelo está relacionado con el retraso del vuelo inmediatamente anterior.

6. Mira cada destino. ¿Puedes encontrar vuelos sospechosamente rápidos? (es decir, vuelos que representan un posible error de entrada de datos). Calcula el tiempo en el aire de un vuelo relativo al vuelo más corto a ese destino. ¿Cuáles vuelos se retrasaron más en el aire?

7. Encuentra todos los destinos que son volados por al menos dos operadores. Usa esta información para clasificar a los transportistas.

8. Para cada avión, cuenta el número de vuelos antes del primer retraso de más de 1 hora.
