### Vectores

Introducción

Hasta ahora este libro se ha enfocado en tibbles y sus paquetes correspondientes. Pero como empezaste a escribir tus propias funciones, y a profundizar en R, es que necesitas aprender sobre vectores, es decir, sobre los objetos que soportan los tibbles. Por esto, es mejor empezar con tibbles ya que inmediatamente puedes ver su utilidad, y luego trabajar a tu manera con los componentes que están debajo, los vectores.
Los vectores son particularmente importantes, al igual que la mayoría de las funciones que escribirás y utilizarás con dichos vectores. Es posible desarrollar funciones que trabajen con tibbles (como ggplot2, dplyr and tidyr) pero las herramientas que necesitas para ello son peculiares e inmaduras. Por esto, estoy desarrollando un mejor enfoque, el cual puedes consultar en https://github.com/hadley/lazyeval, pero este no estará listo a tiempo para la publicación del libro. Incluso aún cuando esté completo, de todas maneras necesitarás entender el concepto de vectores, esto solo facilitará la escritura de capas finales que sean user-friendly (amigables al usuario).


### Pre-requisitos

Este capítulo se enfoca en las estructuras de datos de R base, por lo que no es esencial cargar ningún paquete. Sin embargo, usaremos un conjunto de funciones del paquete purrr para evitar algunas insonsistencias en R Base.

```{r setup, message = FALSE}
library(tidyverse)
```

## Vectores básicos

There are two types of vectors:

1. _Hay dos tipos de vectores:
1.	Vectores atómicos, de los cuales existen seis tipos: lógico o booleano, entero, doble o real, carácter, complejo y raw (que consisten en datos sin procesar). Los vectores de tipo  entero y doble son ampliamente conocidos como vectores númericos.
2.	Las listas, las cuales son denominadas en ciertas ocasiones como vectores recursivos debido a que pueden contener otras listas.. 

La diferencia principal entre vectores atómicos y listas es que los vectores atomicos son homogéneos, mientras las listas pueden ser heterogéneas. Existe, otro objeto relacionado: Null (nulo). El nulo es a menudo usado para representar la ausencia de un vector (como el opuesto a NA el cual es usado para representar la ausencia de un valor en un vector.) Null típicamente se comporta como un vector de longitud cero 0. Figura @ref (fig:datatypes) resume las interrelaciones.


```{r datatypes, echo = FALSE, out.width = "50%", fig.cap = "The hierarchy of R's vector types"}
knitr::include_graphics("diagrams/data-structures-overview.png")
```

Cada vector tiene dos propiedades claves: 

1.  Su tipo (__type__), el cual puedes determinarlo con la sentencia typeof() (del inglés tipode).

    ```{r}
    typeof(letters)
    typeof(1:10)
    ```

1. Su longitud (__length__), la cual puedes determinarla con la sentencia length() (del ingés longitud).

    ```{r}
    x <- list("a", "b", 1:10)
    length(x)
    ```

Los vectores pueden contener también arbitrariamente metadata adicional en forma de atributos. Estos atributos son usados para crear vectores aumentados los cuales implican un comportamiento distinto. Existen tres tipos de vectores aumentados:
	Los factores (factors) construidos a partir de vectores de enteros.
	Las fechas y fechas-tiempo (date-time) construidos a partir de vectores numéricos.
	Los Dataframes y tibbles construidos a partir de listas.
Este capítulo te introducirá a lo temas más importantes de vectores, desde lo más simple a lo más complicado. Comenzarás con vectores atómicos, luego seguirás con listas, y finalizarás con vectores aumentados.

## Tipos importantes de vectores atómicos 

Los cuatro tipos más importantes de vectores atómicos son lógico, entero,  real y carácter. Los tipos raw y complejo son raramente usados durante el análisis de datos, por lo tanto no discutiremos sobre ellos aquí.

### Lógico o Booleano
Los vectores de tipo lógico o booleano son el tipo más sencillo de vectores atómicos porque ellos solo pueden tomar tres valores posibles: falso, verdadero y Na. Los vectores lógicos son construidos usualmente con operadores de comparación, como se describe en [comparaciones]. También puedes crearlos manualmente con la función c ():

```{r}
1:10 %% 3 == 0

c(TRUE, TRUE, FALSE, NA)
```

### Numérico

Los vectores compuestos por enteros o reales son conocidos ampliamente como vectores numéricos. En R, los números son por defecto, reales. Por lo que, para generar un entero, debes colocar una L después del número:

```{r}
typeof(1)
typeof(1L)
1.5L
```

La distinción entre enteros y reales no es realmente importante aunque existen dos diferencias relevantes de las que debes ser consciente:
1.	Los números dobles o reales son aproximaciones. Los mismos representan números de punto flotante que no pueden ser precisamente representados con un monto fijo de memoria. Esto significa que debes considerar que todos los reales sean aproximaciones. Por ejemplo, ¿cuál es el cuadrado de la raíz cuadrada de dos?


    ```{r}
    x <- sqrt(2) ^ 2
    x
    x - 2
    ```

Este compartamiento es común cuando trabajas con números de punto flotante: la mayoría de los cálculos incluyen algunos errores de aproximación. En lugar de comparar números de punto flotante usando `==`, debes usar ´dplyr::near()`, el cual provee tolerancia numérica.

1.  Los números reales tienen cuatro tipos de valores posibles: NA, NaN, Inf and –Inf. Estos tres valores especiales NaN, Inf and -Inf pueden surgir a partir de la división de
c(-1, 0, 1) / 0
Evita usar ==  para chequear estos valores especiales. En su lugar usa la funciones de ayuda is.finite(), is.infinite(), y is.nan():


    
    |                  |  0  | Inf | NA  | NaN |
    |------------------|-----|-----|-----|-----|
    | `is.finite()`    |  x  |     |     |     |
    | `is.infinite()`  |     |  x  |     |     |
    | `is.na()`        |     |     |  x  |  x  |
    | `is.nan()`       |     |     |     |  x  |

### Caracter

Los vectores compuestos por carácteres son los tipos más complejos de vectores atómicos, porque cada elemento del mismo es un string, y un string puede contener una cantidad arbitraria de datos.
Ya has aprendido un montón acerca de cómo trabajar con strings en [strings]. En este punto quiero mencionar una característica importante  y fundamental en la  implementación de un string: R usa una reserva global de strings. Esto significa que cada string solo es almacenado en memoria una vez, y en cada uso de puntos del string a la representación. Esto reduce la cantidad de memoria necesaria por strings duplicados. Puedes ver este comportamiento en práctica con  pryr::object_size():


```{r}
x <- "Esto es un string razonablemente largo."
pryr::object_size(x)

y <- rep(x, 1000)
pryr::object_size(y)
```
y no utiliza más de 1000x ni tanta memoria como x, porque cada elemento de y es sólo un puntero al mismo string. Un puntero utiliza 8 bytes, entonces 1000 punteros a 136 B string es igual a  8 * 1000 + 136 = 8.13 kB.

### Valores perdidos (Missing values)

Nota que cada tipo de vector atómico tiene su propio valor perdido (o missing value):

```{r}
NA            # logico
NA_integer_   # entero
NA_real_      # real
NA_character_ # caracter
```

Normalmente no necesitas saber sobre los diferentes tipos porque puedes siempre usar el valor NA (not Available), es decir el valor faltante, y se convertirá al tipo correcto usando las reglas de la coerción implícitas. Sin embargo, existen algunas funciones que son estrictas acerca de sus inputs, por lo tanto es útil tener presente este conocimiento así puedes  ser especifico cuando lo necesites.

###Ejercicios

1. Describe la diferencia entre `is.finite(x)`  y `!is.infinite(x)`.
1. Lee el código fuente de `dplyr:: near()` (Consejo: para ver el código fuente, escribe lo siguiente `()`) ¿Funcionó?
1. Un vector de tipo lógico puede tomar 3 valores posibles. ¿Cuántos valores posibles puede tomar un vector de tipo entero? ¿Cuántos valores posibles puede tomar un vector de tipo real? Usa google para realizar buscar información respecto a lo planteado anteriormente.
1. Idea al menos 4 funciones que te permitan convertir un vector del tipo real a entero. ¿En qué difieren las funciones? Sé preciso.
1. ¿Cuáles funciones del paquete readr te permiten convertir un vector del tipo string en un vector del tipo lógico, entero y doble?

## Usando vectores atómicos

Ahora que conoces los diferentes tipos de vectores atómicos, es útil repasar algunas herramientas importantes para así poder utilizarlas. Esto incluye:
1.	Cómo realizar una conversión de un determinado tipo a otro, y en cuáles casos esto sucede automáticamente. 
2.	Cómo decidir si un objeto es un tipo específico de un vector.
3.	Qué sucede cuando trabajas con vectores de diferentes longitudes. 
4.	Cómo nombrar los elementos de un vector
5.	Cómo obtener los elementos de interés de un vector.

### Coerción

Existen dos maneras de convertir, o coercer, un tipo de vector a otro:
1. La Coerción explicita sucede cuando defines a una función como `as.logical()`,  `as.integer()`, `as.double()`, o `as.character()`. Cuando te encuentres usando coerción explicita, siempre debes comprobar que sea posible realizar la corrección en sentido ascendente, de esta manera, en primer lugar, estamos seguros que ese vector nunca tuvo tipos incorrectos. Por ejemplo, quizás necesites la especificación de `col_types` ('tipos de columna') del paquete readr.

1. La Coerción implícita sucede cuando usas un vector en un contexto especifico del cual se espera un cierto tipo de vector. Por ejemplo, cuando usas un vector del tipo lógico con la función numérica 'summary' (del inglés resumen), o cuando usas un vector del tipo doble donde se espera un vector del tipo entero.
Porque la coerción explicita es usada raramente, y es ampliamente fácil de entender, enfocaré sobre la coerción implicita aquí.
Anteriormente vimos el tipo más importante de coerción implicita: usando un vector de tipo lógico en un contexto numérico. En ese caso, el valor `TRUE` ('VERDADERO') es convertido a `1` y 'FALSE' ('FALSO') convertido a 0. Esto significa que la suma de un vector de tipo lógico es el número de los valores verdaderos, y el significado de un vector de tipo lógico es la proporción de valores verdaderos:

    
```{r}
x <- sample(20, 100, replace = TRUE)
y <- x > 10
sum(y)  #¿cuántos valores son más grandes que 10?
mean(y) ) #? ¿cuál es la porporción de valores que son mayores que 10?
```

Quizás veas algún código (tipicamente más antiguo) basado en la coerción implicita pero en la dirección opuesta, es decir, de un valor entero a uno lógico

```{r, eval = FALSE}
if (length(x)) {
  # do something
}
```

En este caso, 0 es convertido a `FALSO` y todo lo demás es convertido a `VERDADERO`. Pienso que esto hace más dificil entender el código, por lo que no lo recomiendo. En su lugar, de ser explicito, sugiero utilizar: `length(x) > 0`.

Es también importante entender que pasa cuando creas un vector que contiene múltiples tipos con `c()`: los tipos más complejos siempre ganan.

```{r}
typeof(c(TRUE, 1L))
typeof(c(1L, 1.5))
typeof(c(1.5, "a"))
```

Un vector atómico no puede contener un mix de diferentes tipos porque el tipo es una propiedad de un vector completo, no de elementos individuales. Si necesitas un mix de múltiples tipos en el mismo vector, entonces debes usar una lista, la cual aprenderás en breve.

### Funciones de test

Algunas veces quieres hacer las cosas de una manera diferente basadas en el tipo de vector. Una  de las opciones es el uso de la sentencia `typeof()`. Otra es usar una función test la cual devuelva un valor `TRUE` o 'FALSO' . R base provee varias funciones como `is.vector()` y `is.atomic()`, pero estas a menudo devuelven resultados inesperados. En su lugar, es más acertado usar las funciones `is_*` provistas por el paquete purrr, las cual están resumidas en la tabla que se muestra a continuación.

|                  | lgl | int | dbl | chr | list |
|------------------|-----|-----|-----|-----|------|
| `is_logical()`   |  x  |     |     |     |      |
| `is_integer()`   |     |  x  |     |     |      |
| `is_double()`    |     |     |  x  |     |      |
| `is_numeric()`   |     |  x  |  x  |     |      |
| `is_character()` |     |     |     |  x  |      |
| `is_atomic()`    |  x  |  x  |  x  |  x  |      |
| `is_list()`      |     |     |     |     |  x   |
| `is_vector()`    |  x  |  x  |  x  |  x  |  x   |

Cada predicado además viene con una version para "escalares", donde la función `is_scalar_atomic()`, chequea que la longitud sea 1. Esto es útil, por ejemplo, si quieres chequear en algún argumento que tu función sea un solo valor lógico.

###Escalares y reglas de reciclado 

Así como implicitamente se coercionan los tipos de vectores que son compatibles, R también implicitamente coerciona la longitud de los vectores. Esto se denomina vector __recycling__, o reciclado de vectores, debido a que el vector de menor longitud se repite, o recicla, hasta igualar la longitud del vector de mayor longitud.
Esto es generalmente lo más útil cuando estás trabajando con vectores y "escalares". Los escalares están puestos en notas porque R en realidad no tiene definido los escalares: en su lugar, un solo número conforma un vector de longitud 1. Debido a que no existen los escalares, la mayoría de las funciones están construidas como vectorizadas, esto significa que operan sobre un vector del tipo númerico. Esto es así porque, por ejemplo, este código funciona:

```{r}
sample(10) + 100 (del inglés muestreo)
runif(10) > 0.5
```

En R, las operaciones matemáticas básicas funcionan con vectores. Lo que significa que no necesitarás la ejecución de una interación explicita cuando realices  cálculos matemáticos sencillos.
Es intuitivo lo que debería pasar si agregas dos vectores de la misma longitud, o un vector y un "escalar", pero ¿qué sucede si agregas dos vectores de diferentes longitudes?

```{r}
1:10 + 1:2
```

Aquí, R expandirá el vector de menor longitud a la misma longitud del vector de mayor longitud, a esto es lo que denominamos reciclaje o reutilización de un vector. Esto es una excepción cuando la longitud del vector de mayor longitud no es un múltiplo entero de la longitud del vector más corto:

```{r}
1:10 + 1:3
```

Mientras el vector reciclado puede ser usado para crear código claro y conciso, también puede ocultar problemas de manera silenciosa. Por esta razón, las funciones vectorizadas en tidyverse mostrarán errores cuando recicles cualquier otra cosa que no sea un escalar. Si quieres reutilzar, necesitarás hacerlo tu mismo con la sentencia `rep()`:

```{r, error = TRUE}
tibble(x = 1:4, y = 1:2)

tibble(x = 1:4, y = rep(1:2, 2))

tibble(x = 1:4, y = rep(1:2, each = 2))
```

### Nombrando vectores

Todos los tipos de vectores pueden ser nombrados. Puedes asignarles un nombre al momento de crearlos con `c()`:

```{r}
c(x = 1, y = 2, z = 4)
```

O después de la creación con `purrr::set_names()`: 

```{r}
set_names(1:3, c("a", "b", "c"))
```

Los vectores con nombres son más útiles para subconjuntos, como se describe a continuación.



### Subsetting (creación de subconjuntos) {#vector-subsetting,  creación de subconjuntos de vectores}

Hasta ahora hemos usado `dplyr::filter()` para filtrar filas en una TIBBLE. La sentencia `filter()` sólo funciona con TIBBLES, por lo que necesitaremos una nueva herramienta para trabajar con vectores: `[`. `[` representa a la función Subsetting, la cual nos permite crear subconuntos a partir devectores, y se indica como `x[a]`. Existen cuatro tipos de cosas en las que puedes subdividir un vector:

1.  Un vector numérico contiene sólo enteros. Los enteros deben ser todos positivos, todos negativos, o cero. 

    La Subdivisión con enteros positivos mantiene los elementos en aquellas posiciones:

    ```{r}
    
    ```{r}
    x <- c"uno", "dos", "tres", "cuatro", "cinco")
    x[c(3, 2, 5)]
    x[c(3, 2, 5)]
    ```
    
     Repitiendo una posición, puedes en realidad generar un output de mayor longitud que el input::
    
    ```{r}
    x[c(1, 1, 5, 5, 5, 2)]
    ```
   Los valores negativos eliminan elementos en posiciones especificas: 
    
    ```{r}
    x[c(-1, -3, -5)]
    ``` 
   Es un error mezclar valores positivos y negativos:
    
    
    ```{r, error = TRUE}
    x[c(1, -1)]
    ```

  El mensaje menciona subdivisiones utilizando cero, lo cual no returna valores.
    
    ```{r}
    x[0]
    ```
    
     Esto a menudo no es útil, pero puede ser de ayuda si quieres crear estructuras de datos inusuales para testear tus funciones. 

 
1. La subdivisión de un vector lógico mantiene/almacena todos los valores correspondientes al valor `TRUE` `VERDADERO`. Esto es a menudo mayormente útil en conjunto con las funciones de comparación.

    
    ```{r}
    x <- c(10, 3, NA, 5, 8, 1, NA)
    
    # Todos los valores non-missing, es decir, distintos de NA  de x  
    x[!is.na(x)]
    
    # Todos, incluso los  valores (missing) de x 
    x[x %% 2 == 0]
    ```
1.   Si tienes un vector con nombre, puedes subdivirlo en un vector de tipo caracter.
    
    
    ```{r}
    x <- c(abc = 1, def = 2, xyz = 5)
    x[c("xyz", "def")]
    ```
    
   Como con los enteros positivos, también puedes usar un vector del tipo caracter para duplicar entradas individuales.
    
1.  El tipo más sencillo de subsetting es el valor vacío, `x[]`, el cual retorna el valor completo de `x`. Esto no es útil para vectores subdivididos, aunque si lo es para matrices subdivididas(y otras estructuras de grandes dimensiones) ya que te permite seleccionar toda las filas o todas las columnas, dejando el indice en blanco. Por ejemplo, si `x` está en la segunda posición, `x[1, ]` selecciona la primera fila y todas las columnas, y la expresión `x[, -1]` selecciona todas las filas y todas las columnas excepto la primera.

 Para aprender más acerca de las aplicaciones de subsetting, puedes leer el capítulo de Subsetting de R Avanzado: <http://adv-r.had.co.nz/Subsetting.html#applications>.
    
    Existe una importante variación de `[`, la cual consiste en `[[`. Esta expresión `[[` sólo extrae un único elemento, y siempre omite nombres. Es una buena idea usarla siempre que quieras dejar en claro que estás extrayendo un único item, como en un bucle for. La diferencia entre `[` y`[[` es más importante para las listas (lists), como veremos en breve.

### Ejercicios

1.  La expresión `mean(is.na(x))`, ¿qué dice acerca del vector 'x'? ¿y qué sucede con la expresión `sum(!is.finite(x))`?

1.  Detenidamente lee la documentación de `is.vector()`. ¿Para qué se prueba la función realmente? ¿Por qué la función `is.atomic()` no concuerda con la definición de vectores atómicos vista anteriormente?
    
1.  Compara y contraste `setNames()` con `purrr::set_names()`.

1. Crea funciones que tomen un vector como entrada y devuelva:
	1. El último valor. ¿Deberás usar `[` o `[[`?.
	1. Los elementos en posiciones pares.
	1. Cada elemento excepto el último valor. 
	1. Sólo las posiciones pares (y sin valores perdidos (missing values)).
	1. ¿Por qué `x[-which(x > 0)]` no es lo mismo que `x[x <= 0]`? 
	1. ¿Qué sucede cuando realizas un subset (subdivisión) con un entero positivo que es mayor que la longitud del vector? ¿Qué sucede cuando realizas un subset (subdivisión) con un nombre que no existe?


